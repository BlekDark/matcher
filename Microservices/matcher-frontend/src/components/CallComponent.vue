<template>
  <div class="title">Вызовы</div>
  <div class="call-items">
    <div v-if="this.filteredTasks().length !== 0"
         v-for="task in this.filteredTasks()"
         :key="task.task_id"
         class="call-item"
         :class="[
             isSelected(task) ? 'enabled' : '',
             currentStatus(task.status_user),
             currentObserverStatus(task.status_observer),
             isTestTask(task.referent_task)
             ]"
         @click="onCallClick(task)"
         :title="titleText(task)"

    >
      <div class="call-title">Вызов {{ task.task_id }}</div>
      <div class="call-initial" v-if="task.referent_task !== null">Исходный вызов: {{ task.referent_task }}</div>
      <div class="call-runtime">{{ calculateRuntime(task) }}</div>
      <div class="call-matched">Сматчено системой: {{ task.num_matches }}</div>
      <div class="call-event-num">Событий у источника 1: {{ task.source1_count }}</div>
      <div class="call-event-num">Событий у источника 2: {{ task.source2_count }}</div>
    </div>
    <div v-else style="text-align: center">
      Вызовы отсутствуют
    </div>
  </div>
</template>

<script>
import {ElNotification} from 'element-plus';

export default {
  name: "CallComponent",
  props: [
    'data',
    'dateTimeRange',
    'currentMode'
  ],
  emits: [
    'taskSelected',
    'dateTimeRange'
  ],
  data() {
    return {
      tasks: [],
      dateTime: [],
    }
  },
  computed: {

  },
  methods: {
    onCallClick(task){
      this.$emit('taskSelected', task)
    },
    isSelected(task) {
      return this.$parent.selectedTask.task_id === task.task_id;
    },
    titleText(task) {
      if (this.tasks.length){
        const timeOptions = {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          timeZoneName: 'short'
        }

        const startedAt = new Date(task.started_at);
        const startedAtFormatted = startedAt.toLocaleString('ru-RU', timeOptions);

        const title = `Вызов ${task.task_id} | ${startedAtFormatted}`;

        if (task.finished_at) {
          const finishedAt = new Date(task.finished_at);
          const finishedAtFormatted = finishedAt.toLocaleString('ru-RU', timeOptions);
          return `${title} - ${finishedAtFormatted}`;
        } else {
          return title;
        }
      } else {
        return ''
      }
    },

    currentStatus(user_id){
      let status = {
        1: 'not-viewed',
        2: 'in-progress',
        3: 'processed',
      }
      return status[user_id]
    },

    currentObserverStatus(observer_id){
      let status = {
        1: 'not-viewed',
        2: 'test-matched',
        3: 'temp',
      }
      return status[observer_id]
    },

    isTestTask(referent_task){
      if (referent_task){
        return 'referent_task'
      }
    },

    filteredTasks(){
      let filteredTasks = this.tasks;

      if (this.dateTime.length > 0){
        filteredTasks = filteredTasks.filter(task => {
          const startedAt = new Date(task.started_at);
          const startedAtTimestamp = startedAt.getTime() - startedAt.getTimezoneOffset() * 60 * 1000;
          return startedAtTimestamp >= this.dateTime[0] && startedAtTimestamp <= this.dateTime[1];
        });
      }

      // Check task - not generated by test_matcher
      if (this.currentMode === 0){
        filteredTasks = filteredTasks.filter(task => task.referent_task === null);
        filteredTasks.forEach(task => task.status_observer = 1)
      }

      // Check task - processed by user
      if (this.currentMode === 2){
        filteredTasks = filteredTasks.filter(task => (task.status_user === 2 || task.status_user === 3) );
      }

      return filteredTasks;
    },

    calculateRuntime(task) {
      if(task.finished_at){
        const startedAt = new Date(task.started_at);
        const finishedAt = new Date(task.finished_at);

        const delta = finishedAt.getTime() - startedAt.getTime();
        if (delta >= 1000) {
          const deltaSeconds = (delta / 1000).toFixed(2);
          return `Время выполнения: ${delta} мс (${deltaSeconds} сек)`;
        } else {
          return `Время выполнения: ${delta} мс`;
        }
      } else {
        return 'Матчинг не окончен'
      }

    }

  },
  watch: {
    data(newVal) {
      this.tasks = newVal.sort((a, b) => new Date(b.started_at) - new Date(a.started_at));
    },

    dateTimeRange(newVal){
      this.dateTime = newVal
    }
  }
}
</script>

<style scoped>
.title {
  text-align: center;
  font-weight: bold;
  font-size: 18px;
  height: 5%;
  flex-basis: 5%;
  display: flex;
  align-items: flex-end;
  justify-content: center;
}

.call-items{
  padding: 20px 20px 0;
  height: 95%;
  flex-basis: 95%;
  overflow: auto;
}

.call-item {
  padding: 15px;
  margin-bottom: 15px;
  text-align: center;
  border: 1px solid var(--color-text);
  cursor: pointer;
  transition: all 0.1s ease-in-out;
}

.call-item:hover {
  background-color: rgb(131, 136, 141) !important;
  color: black;
}

.call-item:last-child {
  margin-bottom: 0px;
}

.call-initial{
  font-size: 10px;
}

.call-runtime{
  font-size: 12px;
}

.call-matched{
  font-size: 12px;
}

.call-event-num{
  font-size: 12px;
}

.not-viewed{

}

.in-progress{
  background-color: rgba(248, 194, 88, 0.8);
  color: var(--color-background);
  transition: all 0.3s ease-in-out;
}

.processed{
  background-color: var(--el-color-success);
  color: var(--color-background);
  transition:  all 0.3s ease-in-out;
}

.test-matched{
  border: 3px solid #ffc300;
  transition: all 0.3s ease-in-out;
}

.temp{
  border: 3px solid #f8f8f8;
  transition:  all 0.3s ease-in-out;
}

.referent_task{
  border: 3px solid #800080;
  transition:  all 0.3s ease-in-out;
}


</style>